# 기업 신뢰도 측정을 하기 위해선, 기존에는 설문조사 OR FGI(Focus Group Interview)를 통해 '의견텍스트'를 수집 후,
   이를 문서화해서 응답의 '출현빈도' 에 따라 분석을 하였다. 따라서 객관적이고 체계적이긴 하나, 의미와 맥락을 해석하기 어렵다는 단점도 존재.

# 여러 사람들이 하나의 대상에 대해 공통적으로 반복해서 사용하는 단어 간의 연결구조를 살펴보면 대상에 대한 어떤 인식을 가지는지 알 수 있다.


# 순서 : 
  1) 데이터 수집 - 2) 데이터 전처리(토큰나이즈, stopwords, stem/lemi, 형태소분석기) - 3) 단어 형태별 출현빈도 분석 
     - 4) 데이터 분석 (출현빈도에 따라 추출된 단어군을 대상으로 상호 관계성 측정) -  5) 시각화
    
    데이터 분석 단계의 핵심 : 단어 간 연결성이 강한 단어를 찾아내는 것.
                            (특히, 많은 단어와 빈번하게 연결되는 "핵심단어" & 특정 단어들을 서로 연결하는 "매개단어(연관단어)")
                            
# python library : NetworkX
  자동설치 :  pip install networkx or sudo apt-get install python-networkx
   ex) import networkx as nx
       import matplotlib.pyplot as plt
       G = nx.Graph()   # 빈 그래프 구조 G 생성
       G.add_edge(1,2)  # 엣지 추가
       nx.draw(G)       # 그래프 G 그리기
       plt.show()       # pyplot으로 보여주기
       

# 노드 정의하는 방법
G = nx.Graph()                                  # to create a new network
G.add_node('apple')                             # 노드 'apple'추가
 
 G.add_nodes_from(['banana', 'kiwi', 'mango'])   # 리스트로 추가 1
     # or 
 fruits= ['banana', 'kiwi', 'mango']
 G.add_nodes_from(fruits)                        # 리스트로 추가 2
  
  G.nodes()                                       # 노드들 보기
  

# 엣지 정의하는 방법
G = nx.Graph()
G.add_edge('apple', 'banana')                     # 노드 'apple'추가

G.add_edges_from([('apple','mango'), ('apple', 'kiwi')])   # 리스트로 추가 1
    # or 
relations = [('apple','mango'), ('apple', 'kiwi')]
G.add_edges_from(relations)                        # 리스트로 추가 2

G.edges()                                           # 노드들 보기


# 노드에 속성 부여하기 1
G.nodes()
>>> ['apple', 'banana', 'kiwi', 'mango']

G.node['kiwi']
>>> {}                 # 딕셔너리 타입으로 나옴

G.node['kiwi']['kind'] = 'fruit'
G.node['kiwi']
>>> {'kind:'fruit'}

G.nodes(data=True)
>>> [('kiwi',{'kind:'fruit'}), ('mango', {}), ('apple': {}), ('banana':{})]


# 노드에 속성 부여하기 2
G.add_node('kiwi', kind='fruit')
G.add_nodes_from(['banana', 'apple'], kind='fruit')
G.nodes['banana']
>>>{'kind:'fruit'}

G.nodes(data=True)
>>> {'apple': {'kind': 'fruit'}, 'banana': {'kind': 'fruit'}, 'mango': {}, 'kiwi': {'kind': 'fruit'}}


# 엣지에 속성 부여하기 1
G.edges()
>>>[('apple', 'banana'), ('apple', 'mango'), ('apple', 'kiwi')]

G.edges(data=True)
>>>[('apple', 'banana', {}), ('apple', 'mango', {}), ('apple', 'kiwi', {})]

G.add_edge('apple', 'mango', weight=2.5)
G.add_nodes_from(relations, color='blue')
G['apple']['mango']['weight']=5
G['apple']['kiwi']['weight']=2


#네트워크가 정의되기 위해선?
   # - 점(objects, vertices, Nodes, Sites, Actors..) / 선(Relations, Edges, Lnks, Bonds, Ties..() 
   # - 점, 선 + 점의 위치
   
   
# 네트워크 그리기
G = nx.Graph()
relations = relations = [('apple','mango'), ('apple', 'kiwi'), ('apple', 'banana')]
G.add_edges_from(relations)       # 점, 선 생성
nx.draw(G)                        # 점의 위치를 spring layout으로 생성
plt.show()


------------------여기서 부터는 DATACAMP 내 SNA 참고함---------------------------

# 네트워크 그리기 2 (여러종류로 그리기)  & Symmetric Networks(in 데이터캠프) 
  # : symmetric Networks means that If A is related to B, B is also related to A.
  
G1 = nx.Graph()                                     
G1.add_edge('Amitabh Bachchan','Abhishek Bachchan')
G1.add_edge('Amitabh Bachchan','Aamir Khan')
G1.add_edge('Amitabh Bachchan','Akshay Kumar')
G1.add_edge('Amitabh Bachchan','Dev Anand')
G1.add_edge('Abhishek Bachchan','Aamir Khan')
G1.add_edge('Abhishek Bachchan','Akshay Kumar')
G1.add_edge('Abhishek Bachchan','Dev Anand')
G1.add_edge('Dev Anand','Aamir Khan')

nx.draw(G1)              # 기본 그리기
nx.draw_networkx(G1)     # 노드명 표시된 기본 그리기
nx.draw_circular(G1)     # 원 위에 노드 놓기
nx.draw_graphviz(G1)     # graphviz 사용
nx.draw_random(G1)       # 균등 분포를 이용한 랜덤
nx.draw_shell(G1)        # 동심원 위에 노드 놓기
nx.draw_spectral(G1)     # 그래프 라플라시안의 고유 벡터 기반
nx.draw_spring(G1)       # Fruchterman-Reingold force-directed alg. 기반


# Asymmetric Networks
 # : A is related to B, does not necessarily means that B is associated with A
 
G_asymmetric = nx.DiGraph()           # 비대칭 구조의 경우, nx.DiGraph()를 사용해야 함
G_asymmetric.add_edge('A','B')
G_asymmetric.add_edge('A','D')
G_asymmetric.add_edge('C','A')
G_asymmetric.add_edge('D','E')

nx.draw_networkx(G_asymmetric)        # 시각화 1,  기본 방법

nx.spring_layout(G_asymmetric)        # 시각화 2,  노드가 막 뻗치지 않고, 각 노드별 거리가 동일하게끔 만든 
nx.draw_networkx(G_asymmetric)

